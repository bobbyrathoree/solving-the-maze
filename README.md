# Assignment 0
## Part 1: Finding your way

In the first part of the assignment, we're given a skeleton code that starts out by assuming the fringe to be a stack, which is not the way to go for a search algorithm #1 in this case. Whenever a node is visited, it should be FIFO-d, which means its neighboring nodes should be explored first. In the given skeleton code however, when a new node is added to the fringe, it is explored right away, instead of the older (parent) one.

I could've used a priority queue for this problem since it is similar to Dijkstra's algorithm, but decided to with a regular queue with a little twist. Along with the coordinates of the node that is to be explored next, I coupled it with the path it took to get there as a tuple, which takes care of "backtracking" automatically.

I altered the default moves that are fixed throughout the scope of the problem: added directions (N,S,E,W) to each of them as part of a tuple. This helps us in keeping track of visited states. Speaking of which, changing a stack to a queue pretty much solved the problem (outputs the correct distance travelled till Luddy Hall). But it is not optimized, since it goes through the visited states multiple times, hence increasing overhead. To prevent it from doing that and to solve the problem in literally 1/10th the time, I added a list to keep track of the nodes that have been visited. So, now when we talk about valid moves, it also includes not being in the visited state. _visited_ is a **set** instance to only add to it **unique** nodes coordinates.

Whenever a solution is not found, it had to return _None_. To implement that, I took some time to come up with a solution that didn't involve a lot of backtracking. I figured that if all the sidewalks are visited, there is no point in continuing further. So to return _None_ whenever a solution doesn't exist, I compared the length of visited set and the number of sidewalks in the graph (that are fixed no matter what). If they're equal, we arrive at our conclusion.

The set of **valid states** would therefore be ones where the node's coordinates are within the scope of the board, non-visited and be a sidewalk and/or destination (Luddy Hall in this case). The **successor function** is literally the function _moves()_, since it returns the possible moves for a certain state of map. The **cost function** would be 1 since we only move in any of the four directions, one single step at a time. So at the end, the total cost would be the sum of all the steps taken to get to the destination, i.e. Luddy Hall (@). **Goal state** in this problem would be (in theory) the same as the **initial state**, i.e. the input _map.txt_. Since we're not really changing the configuration of the map here, we're only interested in finding out the set of directions it took to get to our destination.




## Part 2: Hide-and-Seek

In the second part of the assignment, we're given a skeleton code that only given a partial solution to the problem. It uses a stack as the fringe. I changed it to a deque, which is essentially a more optimized version of a stack in python. It also often allows friends to see each other, because there is not a proper successor function that decides whether it is appropriate to place a friend at a particular sidewalk. The function _is_safe()_ is an increment to the incomplete successor function that splits the cross section of a sidewalk into 2 lists and checks if it is legal to place a friend there such that it is blocked on all 4 sides by a building.

The solution to the problem is really slow as well, initially. It needs a check upon every pop of the fringe, so it doesn't brute force its way to finding each and every possible combination of legal states. This is where I introduce the _visited_ set, that keeps track of all the visited states for a particular fringe pop. It is also a unique set that only takes in new unvisited states into it, as a string (using the _stringify()_ function), since checking whether a string is in a set is a lot more lightweight than checking a multidimensional list in a set. If there does not exist a solution, I needed a way to figure out that the program doesn't go in infinite loop, so I made another function _check_number_of_friends()_ that keeps check that the execution doesn't enter an infinite curve after every 2^n seconds, exponentially. What it basically does is check the solution board every once in a while: if it hasn't changed the number of friends for a particular state of map, it exits the execution cycle and returns "No solution found."

This search abstraction is #2, since we've introduced a new data structure here that takes care of visiting the same set of states more than once. Suppose we've placed friend #1 at (0,0), then our **state space** would be the set of all states such that another friend #2 could be added in a way that is legal, i.e there are buildings between them, in either of the 4 directions. The **initial state** is the one where there are no friends placed on the map, i.e the initial one. The **final state** is the one where all _k_ friends are placed on the board such that none can see each other. The **successor function** is the _successors()_ method paired with _is_safe()_. These two functions determine the next set of sidewalks where a friend can be placed. The **cost function** here is 1 as well, since we only add one friend on the map at a time.